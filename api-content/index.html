{"posts":[{"title":"JavaScript复习（一）","content":"一、专业素养 互联网历史第一个浏览器：Mosaic 浏览器组成：Shell部分 + 内核部分 （渲染引擎 JS引擎 其他模块） 2008年Google发布Chrome，Chrome采用优化后的JS引擎，代号“V8引擎”。 人写的代码不能直接被计算机执行（计算机只认识“0和1”），所以需要经过翻译。翻译有两种方式：编译和解释 编译：全部翻译完成，生产翻译文件，再执行翻译文件。 优点：快 不足：移植性不好，不能跨平台 C C++ Ruby 解释：翻译一行，执行一行 优点：稍微慢 不足：跨平台 JavaScript php Python 单线程与多线程（计算机的同步异步与生活相反） 单线程：一个执行体同一时间只能做一次事情 （同步）JavaScript是单线程的 多线程：一个执行体同时能干很多事情 （异步） 二、学习JavaScript JavaScript特点：解释性、单线程 JS的三大部分：ECMAScript、DOM、BOM JS是如何执行的？采用轮转时间片的方式。 JS引擎把许多任务分成许多片段，依次传送执行，由于执行速度过快，所以看起来像是在一起执行的。 （1）引入js 页面级引入： 外部引入： 一般写在body尾标签后面 如果既引入页面级，又引入外部。则外部优先级&gt;页面优先级 （2）基本语法 变量（variable），相当于一个筐，一个房间。 声明变量并赋值 var a；向系统申请一个房间（筐）---声明变量 a = 100；将100赋值到a里面去 ---变量赋值 var a = 100；---定义变量 实际开发中，一般同时声明多个变量，并同时赋值。 var a = 10， b = 20， c = 30， d = 40， e = 50； 替换变量的值 var a = 10； a =20； 变量名命名规则：1、变量名必须以英文字母、_、开头2、变量名可以包括英文字母、、开头 2、变量名可以包括英文字母、_、开头2、变量名可以包括英文字母、、​、数字 3、不可以用系统的关键字，保留字作为变量名 关键字：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 保留字：abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 变量名网站：https://unbug.github.io/codelf/ 书写格式要规范，“=”“+”“/”&quot;-&quot;两边都应该有一个空格 语句后面要用分号结束“；” //特例 function test(){} for (){} if(){} js语法错误会引发后续代码终止，但不会影响其他js代码块 错误分成两种 1、低级错误（语法解析错误） 2、逻辑错误（标准错误，情有可原） &lt;script&gt; var a = 10; document.write(c); &lt;/script&gt; &lt;script&gt; var b = 20; document.write(b); &lt;/script&gt; （3）数据类型——由值决定类型 数据类型分为 原始值 和 引用值 原始值 Number String Boolean underfined null 数字 字符串 逻辑值（true/false） 变量未赋值 占位 引用值 arry Object function ...date RegExp 数组 对象 申请变量赋值时，如果变量是原始值，那么系统记录的是值本身。如果变量是引用值，那么系统记录的是值的地址。 原始值赋值到原始值，拷贝的是值，所以改变原来的原始值，现在的不会改变。 引用值赋值到引用值，拷贝的是地址，所以改变原来的引用值，现在的也会跟着改变。 （4）运算操作符 +： （1）数字运算 （2）字符串连接 注意：任何数据类型加字符串都等于字符串 减：- 乘：* 除：/ 取余：% 赋值：= 括号：（） 加加：++（自身加1再赋值给自身） 减减：--（自身减1再赋值给自身） var a = 10; document.write(a++); 先输出a，再加加 document.write(a); document.write(++a); 先加加，再输出a var a = 10; var b = ++a - 1 + a++; document.write(b + &quot; &quot; + a); var a = 10; a += 10; a加10，然后赋值给自身，相当于 a = a + 10; var a = 1： var b = a++ + 1： document.write(a); document.write(b); b=2 因为a++ 要先等这条语句执行完才会+1 var a = 1； var b = a-- + --a; document.write(b); b=0 因为看到了--a,所以要先算--a这个运算，然后再算其他的 doucment.write(a); a=-1 var a = 1; var b = --a + --a; document.write(b); ++ 放后面，等整条语句执行完，在+1的运算 ++ 放前面，先执行+1的那个运算，在执行整条语句 其他 -- 同理 （5）比较运算符 大于：&gt; 小于：&lt; 等于等于：== 比较是否相等 大于等于：&gt;= 小于等于：&lt;= 叹号等于：！= 比较是否不相等 NaN不等于任何数，包括自己 比较结果boolean值，只能是 true（1） 或 false（0） 如果比较的是字符串，则比较的是字符串的ASCII顺序 （6）逻辑运算符 与：&amp;&amp; 找假的表达式，并返回表达式的值，如果都为真，则返回最后表达式的值（返回的是表达式的值，并不是boolean值） 或：|| 找真的表达式，并返回表达式的值，如果都为假，则返回最后表达式的值（返回的是表达式的值，并不是boolean值） 非（取反）：！ 先变成boolean值，然后取反。 被认为是false的值：underfined，null，NaN，“”（空字符串），0，false （7）条件语句---if else if(条件){语句} 先把条件转换成boolean值，如果为true，则执行，为false则不执行。 if(条件){语句}else if(){} 满足条件：条件具有互斥性 if else 语句与 短路语句 类似 if(1 &gt; 2){ document.write(&quot;a&quot;); } ===&gt; 1 &gt; 2 &amp;&amp; document.write(&quot;a&quot;); （8）循环语句---for循环 for 循环 for(var i = 0; i &lt; 10; i++) { document.write(i); //循环体 } 另一种写法 var i = 0; for ( ; i &lt; 10 ; ) { document.write(i); i++; } 执行顺序： 1、var i = 0 //定义变量 2、if(i &lt; 10){document.write(i);} //判断 3、i++ --&gt; i=1 4、if(i &lt; 10){document.write(i);} 5、i++ 先执行一遍（1） 判断（2）执行语句 执行（3） 注意：i++ 永远都是循环的最后一步。 （9）while循环 while 循环就是 for 循环的简化版 while (i &lt; 10) { document.write(i); i++; } （10）do while循环 do while 循环 不管满不满足，先执行一次，在判断 var i = 0; do { document.write(&quot;a&quot;) i++; } while(i &lt; 10) （11）switch case语句 var n = &quot;a&quot;/2/true; switch (n) { case &quot;a&quot; : console.log(a);break; case 2 : concole.log(b);break; case true ：console.log(c);break; } 注意：switch里面的写的是条件，case后面跟的是值。只要判断n的值等于&quot;a&quot;/2/true，就执行后面的代码。 如果不增加break，那面就会连带后面的语句一起输入，比如n=2时，就会打印出b和c。 break的作用：终止循环，需放在循环体里面。 continue：终止本次循环，进行下一次循环。 数组 声明数组：var arr = [1,2,3,&quot;fan&quot;,underfined]; 数组的第一位是0开始的，因此取出数组里第一位的值 arr[0]; 最后一位的值 arr[arr.length - 1]; 遍历数组通用方法 for （var i = 0; i &lt; arr.length; i++） { console.log(arr[i]); } 对象 声明对象 var obj = {name:&quot;fan&quot;, age:20}; 中间用逗号，最后用分号 取值：console.log(obj.name); 赋值：obj.name=&quot;deng&quot;; typeof()：告知你，数据是何种类型。 var num = true; console.log(typeof(num)); typeof()可以返回的值：number string boolean object underfined function 类型转换 1、显示类型转换 Number()：将括号里的值转换为数值类型，不能转的用NaN代替。最后的都是数值类型。 parseInt()：转换成整数。没有小数点。不能转的用NaN代替。 var demo = &quot;b&quot;; var num = parseInt(demo); //把b转换成整数 NaN var num = parseInt(demo,16); //把b当做16进制转换成10进制 parseFloat()：转换成浮点类型，不能转的用NaN代替。 toString() ===&gt; demo.toString underfined和null不能用toString var demo = 1010101010; var num = demo.toString(16); //把demo转换成16进制。 10000 转换成 16 进制 先由2进制转成10进制，在转成16进制 var num = 10000; var test = parseInt(num,2); console.log(test.toString(16)); String()：转换成字符串 Boolean()：转换成布尔类型 2、隐式类型转换 isNaN(&quot;abc&quot;) 判断参数是否是NaN Number(&quot;abc&quot;) ---&gt; NaN ++/-- +/- ---&gt; Number() var a = &quot;abc&quot;; a++; 先把a转换为number形式再加加 --&gt; Number(a) a--; 同上 +a; 调用的也是Number 正号 -a; 调用的也是Number 负号 +(&quot;加号&quot;) ---&gt; String() -*/% ---&gt; Number() &amp;&amp; || ! ---&gt; Boolean() &lt; &gt; &lt;= &gt;= ---&gt; Number() == != 3.不发生类型转换 === ！== NaN不等于任何数，包括自己。 当变量没有被定义在控制台输出时，有且仅有一种情况不会报错。 console.log(typeof(a)); console.log(typeof(typeof(a))); //返回的是String ","link":"https://bonjouryy.github.io/post/JavaScript复习（一）/"},{"title":"JavaScript复习（二）","content":"三、函数 （1）定义 一系列代码语句的集合 （2）声明函数 function test () {} 函数名命名原则：小驼峰原则，多个单词拼接时，第一个单词首字母小写，其余单词首字母大写。 （3）调用函数 test (); ---&gt; 可执行多次 （4）函数表达式 1、命名函数表达式 var test = function test () {} 2、匿名函数表达式 var demo = function () {} （5）函数参数 function test(a , b) { // var a, // var b; // test(a , b) 就相当于在函数体里面 var a; var b; 然后在调用函数的时候，将实际值传给a 和 b; var c = a + b; } test(1 , 2); a b 是形参，1 2 是实参。 function test (a) { // arguments -- [1, 2, 3, 4] 实参列表 这个列表是隐藏的。 console.log(arguments); 可直接输出数组 console.log(test.length); } test (1 , 2 , 3 , 4); 举例说明如下 function test (a , b , c , d) { if(test.length &gt; arguments.length) { console.log(&quot;形参多了&quot;); }else if(tese.length &lt; arguments.length) { console.log(&quot;实参多了&quot;); }else { console.log(&quot;相等&quot;); } } test (1 , 2); function test (a , b) { // var a = 1; a = 2; console.log(arguments[0]); // 输出 2 当形参和实参相等时，arguments[i]与形参的第 i+1 位存在映射关系。 // 当形参的 i+1 位和实参的 arguments[i] 位不对应时，则不存在。 } test (1 , 2); return的作用：1、终止函数 2、用变量接受函数的返回值（把值返回到函数外部） var a = Test(); 3、retuen只能写在函数体里面 function myNumber(target) { return +target; } var num = myNumber(&quot;123&quot;); （6）函数作用域 全局变量：在script标签里定义的变量 局部变量：在函数里面定义的变量 在函数里面可以访问在外面定义的全局变量（嵌套函数也适用），函数外无法访问函数里面的变量。彼此独立的函数不可以相互访问。儿子可以向爸爸、爷爷要钱。但爸爸和爷爷不可以向儿子要钱。 （7）递归 注意点：1、找规律 2、找出口（用已知条件找出口） （9）预编译 JS执行三部曲： 语法分析 预编译 ---&gt; 变量提升 解释执行 函数预编译五部曲：预编译发生函数执行的前一刻 函数声明整体提升，定义变量 声明部分提升，赋值部分不提升。 创建AO对象 Activation Object（执行期上下文） 找形参和变量声明，将变量声明的名和形参名作为AO属性名，值为underfined 将实参值和形参统一 在函数体里面找函数声明，把函数声明的名作为属性名放到AO对象中，值变成相应的函数体 全局预编译四步曲： 函数声明整体提升，定义变量 声明部分提升，赋值部分不提升。 创建GO对象 找变量声明，将变量声明的名作为GO的属性名，值为underfined 找函数声明，把函数声明的名作为属性名放到GO对象中，值变成相应的函数体 imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象（window）所有。 a = 10; ---&gt; window.a = 10; 一切声明的全局变量，全是window的属性。 var a = 10; ---&gt; window.a = 10; window就是全局的域。 （10）作用域链 （11）对象 var mrDeng = { name:&quot;MrDeng&quot;, age:40, sex:&quot;male&quot;, smoke:function(){ console.log(&quot;I am smoking!&quot;); this.health --; //此处一般不用mrDeng，用this（调用属性时，前面必须写对象） }, drink:function(){ console.log(&quot;I am drink&quot;); this.health ++; //此处一般不用mrDeng，用this（调用属性时，前面必须写对象） }, } //创建对象 属性的增删改查 mrDeng.wife = &quot;xiaoliu&quot;; //增加 &amp;&amp; 修改 mrDeng.wife; //查询 delete mrDeng.sex; //删除 对象的属性没有赋值时，将返回undefined; 对象的属性值为函数时，称之为函数的方法。并且可以支持传参，return ---------------------------------------------------------------------- 对象的创建方法 1、var obj = {} //plainObject 对象字面量/对象直接量 2、构造函数 --- 必须要有 new 才行 1）系统自带的构造函数 Object() / Number() / Array() ... var obj = new Object(); obj.name = 'abc'; obj.sex = 'male'; 2）自定义构造函数 --- 命名需采用大驼峰原则：所有单词大字母大写 function Car(color){ this.name = 'BMW', this.height = '1400', this.lang = '4900', this.run = function(){ this.health --; }, this.color = color, } var car1 = new Car('red'); 构造函数内部原理 1、在函数体最前面隐式的加上this={}; 2、执行this.xxx = xxx; 3、隐式的返回this; function Person (name,height){ // var this(); this.name = name, this.height = height, this.say = function (){ console.log(this.say); }, return 123; //如果这边写返回的是原始值，那么无效 return {}; //如果这边写返回的是空对象，则返回空对象 // return this; } var person1 = new Person('xiaowang',180); var person2 = new Person('xiaozhang',175); （12）包装类 原始值是没有属性和方法的，只有对象才有。但是原始值可以利用构造函数将其变成对象。 var num = new Number(123); //此时num就是一个对象，可以给它增加属性 数字类型的对象 var str = new String('abcd'); // 字符串类型的对象 var bol = new Boolean('true'); // 布尔类型的对象 // 包装类 var num = 4; num.len = 3; // 原始值本身是没有属性的，但是如果这样写；系统就会 new Number(4).len = 3 ，把3放进去 然后销毁 delete console.log(num.len); //undefined // 接着当我需要访问num.len,因为之前已经销毁了，所以又会新建一个 new Number(4).len ,所以会返回undefined （13）原型 1、定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该改造函数产生的对象，可以继承该原型的属性和方法。 function Person(){ //定义构造函数 this.name = 'fan'; this.age = 20; } // 当定义一个构造函数后，默认会产生Person.prototype={} Person.prototype.name = 'hehe'; //增加属性，通过Person()这个构造函数制造出的对象默认会继承此属性。 var person = new Person(); console.log(person); console.log(person.name); console.log(person.age); // 一个对象的属性可以有自己的，也可以有 由原型那继承来的。 2、利用原型特点和概念，可以提取共有属性。 Car.prototype.carName = 'BMW'; Car.prototype.height = 1400; function Car (color,owner){ this.owner = owner; this.color = color; } var car = new Car('red','ji'); var car = new Car('green','deng'); ---------------------------------------------------------------------------- 原型属性的增删改查 Car.prototype.xxx = ''; car.xxx = ''; //这种方法是不行的 delete Car.prototype.xxx; delete car.xxx; //这种方法是不行的 Person.prototype = { name:xxx, age:xxx, wife:xxx, } // 原型添加属性也可以是这种写法 3、对象如何查看原型 --&gt; 隐式属性 --&gt; proto function Person(){ // var this ={__proto__:Person.prototype,} //三段式 } var person = new Person(); function obj = { name : 'sunny' } person.__proto__ = obj; //可以更改对象的__proto__属性指向 4、对象如何查看对象的构造函数 --&gt; constructor prototype.constructor; //这个属性里面是构造这个对象的构造函数 function Car(){}; var car = new Car(); car.constructor; // return function Car(){}; （14）原型链 Grand.prototype.lastName = &quot;Deng&quot;; function Grand() {} var grand = new Grand(); Father.prototype = grand; //将Father的原型链指向grand对象 function Father() { this.name = &quot;xuming&quot;; } var father = new Father(); Son.prototype = father; //将Son的原型链指向father对象 function Son() { this.hobbit = &quot;smoke&quot;; } var son = new Son(); console.log(son.lastName); //Deng 原型链的应用 console.log(son.toString()); //返回的是 Object.__proto__的toString()方法 // 原型链的连接点为 __proto__ // 原型的终端为 Object.__proto__ （15）命名空间 目的：解决多人开发时变量命名冲突的问题 变量私有化，不会污染全局变量 var name = 123; var initDeng = (function(){ //立即执行函数 var name = 456; function callName(){ console.log(name); } return function(){ callName(); } }()) initDeng() //456,而不是123 （16）对象的枚举（遍历） 枚举：enumeration var obj = { name: &quot;fan&quot;, age: 20, sex: &quot;male&quot;, }; //定义对象 遍历对象的通用方法：for in 循环 for (var key in obj){ //key里面存放的是各个属性的值，为String类型 console.log(key) //依次输出obj的属性值 console.log(obj.key) //不能这么写，obj.key --&gt; obj[&quot;key&quot;] 而obj没有key这个属性 console.log(obj[key]) //需要这么写才可以 } 一般情况下，如果存在原型链，for in 循环会把原型链的属性也打印出来（但不包括Object.prototype） 所以我们需要在循环之前，先用hasOwnProperty方法判断是否是自己的属性 var obj = { name: &quot;fan&quot;, age: 20, sex: &quot;male&quot;, }; //定义对象 obj.__proto__ = {lastName:&quot;fan&quot;}; for (var key in obj){ if(obj.hasOwnProperty(key)){ //判断属性是否是自己的属性，如果是则打印，不是则不打印 console.log(obj[key]); } } in方法与hasOwnProperty方法的区别 共同点：不管调用哪个方法,返回的都是Boolean值 in：判断对象上面能不能访问到这个熟悉 obj.in(name) //判断obj能不能访问到name属性 hasOwnProperty方法：判断是否是自己本身的属性 obj.hasOwnProperty(name) //判断是否是自己本身的属性，而并非是原型的 instanceof操作符讲解（返回的是Boolean值） A instanceof B //官方定义：A对象是不是B构造函数构造出来的 //老成定义：A对象的原型链上有没有B的原型（B.prototype） 区别一个变量是数组还是对象的三种方法 var demo = arr || object 1、constructer 2、instanceof 3、toString （17）this指向 函数预编译过程 this ---&gt; window AO 全局作用域里 this ---&gt; window GO call/apply 可以改变函数运行时的this指向 obj.function(); function()里面的this指向obj var name = &quot;222&quot;; var a = { name:&quot;1111&quot;, say:function(){ console.log(this.name) } } var fun = a.say; fun(); a.say(); var b ={ name:&quot;333&quot;, say:function(fun){ fun(); } } b.say(a.say); b.say = a.say; b.say(); （18）arguments 首先，需要明确一个定义，arguments只有两个方法 arguments.callee / arguments.length 1、arguments.callee 一般用于立即执行函数 var num = (function (n) { if(n==1){ return 1 } return n * arguments.callee(n - 1); } (100)) 2、caller是函数的属性 function test(){ demo(); } function demo(){ demo.caller; //test 返回的是调用demo方法的那个环境 } test(); （19）克隆 1、浅层克隆 2、深度克隆 var obj = { name:&quot;abc&quot;, age:123, card:[&quot;visa&quot;,&quot;master&quot;], wife:{ name:&quot;bcd&quot;, son:{ name:&quot;aaa&quot; } } } ","link":"https://bonjouryy.github.io/post/JavaScript复习（二）/"},{"title":"关于CSS伪类选择器 _first-child 的坑","content":"p:first-child 寻找p元素的父元素下面的第一个p元素 首先，寻找到第一个元素时，判断第一个元素是不是p元素，如果是，则改变，反之不改变。 CSS代码 p{ font-size:100px; color:orange; } HTML代码 &lt;div&gt; &lt;p&gt;123&lt;/p&gt; //这种就会正常渲染 &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;123&lt;/span&gt; &lt;p&gt;123&lt;/p&gt; //这种就不会正常渲染 &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 注意 :nth-child() 同理 ","link":"https://bonjouryy.github.io/post/关于CSS伪类选择器 _first-child 的坑/"},{"title":"css自定义属性(css变量)","content":"CSS自定义属性也叫CSS变量，用来在最开始的时候定义一个变量，然后可以在整个文档中都可以复用它。 用法：定义变量 和 使用变量 定义变量 变量名以 &quot;--&quot; 开头 例如 element{ --main-bg-color:red; } 使用变量 直接用 var() 来引用变量名 element{ background-color:var(--main-bg-color); } 注意点来咯！！！ CSS的自定义属性是有作用域的，例如上面的定义变量写在 element 这个选择器中，那么就只能在 element 中使用。所以为了能后在全局使用，我们一般提前在 :root 选择器中定义好。 :root{ --main-bg-color:red; --text-color:yellow; } 参考资料：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties ","link":"https://bonjouryy.github.io/post/CSS自定义属性(CSS变量)/"},{"title":"用SSH工具XShell连接谷歌云 root用户或普通用户","content":"目录 1.以root用户登入 2.普通用户，秘钥登入 1.用root用户登入 1.1.进入谷歌云实例面板 1.2.切换到root角色 sudo -i 1.3.修改SSH配置文件/etc/ssh/sshd_config vi /etc/ssh/sshd_config 修改PermitRootLogin和PasswordAuthentication为yes # Authentication: PermitRootLogin yes //默认为no，需要开启root用户访问改为yes # Change to no to disable tunnelled clear text passwords PasswordAuthentication yes //默认为no，改为yes开启密码登陆 1.4.给root用户设置密码 passwd root 1.5.重启SSH服务使修改生效 /etc/init.d/ssh restart 1.6.登录 在xshell中，直接使用root账号密码登录。 2.新建普通用户登入 2.1. 本地用xshell生成密秘钥 2.2. 将秘钥配置到谷歌云上 菜单 — 计算引擎 — 元数据 — SSH秘钥 — 修改 — 添加一项 ** 粘贴刚才从xshell复制的秘钥。在末尾添加 [空格][用户名] 这里就是“ google”，保存即可。 ** 2.3. 用xshell连接 连上之后，输入命令 sudo -i切换到root用户. ","link":"https://bonjouryy.github.io/post/用SSH工具XShell连接谷歌云 root用户或普通用户/"},{"title":"相邻选择器和兄弟选择器的区别","content":"相邻选择器 基本语法：A + B { } 理解：选中A元素后面的 与A元素同级的 一个 B元素 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;相邻选择器/兄弟选择器&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;style&gt; div + p { color:red; // 2 变红 3 不变红 } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 兄弟选择器 基本语法：A ~ B { } 理解：选中A元素后面的 与A元素同级的 所有 B元素 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;相邻选择器/兄弟选择器&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;style&gt; div ~ p { color:red; // 2 和 3 都会变红 } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://bonjouryy.github.io/post/相邻选择器和兄弟选择器的区别/"},{"title":"HTML5新特性-Canvas笔记","content":"Canvas在HTML5中是画板的意思，如果想要在HTML5中应用Canvas，则加入&lt;canvas&gt;&lt;/canvas&gt;即可 1）利用canvas画矩形 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Canvas画板&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;!--引入canvas画板需要设置过id、width、height,有时还需要设置border--&gt; &lt;canvas id=&quot;mycanvas&quot; width=&quot;400px&quot; height=&quot;300px&quot;&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;/html&gt; var c = document.getElementById(&quot;mycanvas&quot;); //首先找到画板元素 var ctx = c.getContext(&quot;2d&quot;); //根据画板元素得到对象，意思是寻找到笔 ctx.fillStyle(&quot;#FF0000&quot;); //设置属性 ctx.fillRect(0,0,200,150); //利用fillRect方法开始作图 四个参数分别是 fillRect(x,y,width,height) 2）利用canvas画线 var c = document.getElementById(&quot;mycanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); //设置开始坐标 ctx.lineTo(200,150); //设置终点坐标 ctx.stroke(); 3）利用canvas画圆 var c = document.getElementById(&quot;mycanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.beginPath(); ctx.arc(200,150,80,0,Math.PI); //设置属性 五个参数分别是 圆心的x轴和y轴坐标、半径、开始弧度、终点弧度（弧度是顺时针旋转） 4）利用canvas绘制文本 var c = document.getElementById(&quot;mycanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); ctx.font=&quot;30px Arial&quot; //设置字体的大小和样式 ctx.fillText(&quot;Hello World&quot;,200,150) //字体文本，字体坐标 5）把图像放到canvas画板上 var c = document.getElementById(&quot;mycanvas&quot;); var ctx = c.getContext(&quot;2d&quot;); var img = document.getElementById(&quot;myimg&quot;); //myimg需要在html中添加 ctx.drawImage(img,10,10); //图像名、图像坐标 6）在canvas画线性渐变和径向渐变 这一点还没有学到，等学到了再来补充笔记。。。 ","link":"https://bonjouryy.github.io/post/HTML5新特性-Canvas笔记/"},{"title":"HTTP入门笔记","content":"HTTP协议 Q：当我们在浏览器的地址栏输入URL时，背后发生了哪些事情？ A：1）首先浏览器判断用户输入的URL是否是正确的，如果不是，则利用默认搜索引擎进行搜索。 2）如果是正确的，则先经过DNS服务器解析，DNS服务器解析的目的是把域名转换成IP地址。 3）寻找到IP地址后，开始向服务器发送HTTP请求，请求是一报文的形式发送出去的，报文的大小是有限制的，所以一般会把报文分割成很多个小的数据包依次发送。服务器接收到这些请求之后，再进行拼合。服务器根据请求知道客户端需要什么，再给浏览器发送HTTP响应，浏览器收到响应后，把页面渲染出来。 客服端浏览器主动发起一个HTTP request 服务器接收到HTTP请求后，做出相应的逻辑处理 服务器返回一个HTTP response 浏览器接收到响应后，做出相应的逻辑处理 Http request 报文 和 Http response 报文 的组成 一个Htpp request报文包括： 请求方法 methods：GET、POST、PATCH 等 请求地址 URL 请求头 Headers：以键值对的形式存在，描述报文的基本信息 请求体 Body：报文的具体内容 一个Http response报文包括： 状态码 Status code：200 404 等 响应头 Headers 响应体 Body ","link":"https://bonjouryy.github.io/post/HTTP入门笔记/"},{"title":"HTML&CSS复习","content":"HTML部分 HTML：hyperText markup language 超文本标记语言 **设置浏览器参数** **给用户所看** 乱码问题： 字符集：gb2312 gbk（包括繁体） Unicode utf-8（万国码） 一、标签 段落标签： 成段展示，独占一行 标题标签： 依次变小，独占一行 加粗标签： 斜体标签： 删除线标签： 地址标签： 斜体+成段展示 容器标签 ：独占一行 ：不独占一行 作用：分块明确，让整个页面更加结构化 捆绑操作的作用（搬书架） &lt;strong color=&quot;red&quot;&gt; a &lt;/strong&gt; &lt;em color=&quot;red&quot;&gt; b &lt;/em&gt; &lt;del color=&quot;red&quot;&gt; c &lt;/del&gt; &lt;div color=&quot;red&quot;&gt; &lt;strong&gt; a &lt;/strong&gt; &lt;em&gt; b &lt;/em&gt; &lt;del&gt; c &lt;/del&gt; &lt;/div&gt; 空格是分隔符，不代表文本的空格。作为分隔符，打多少个都只显示一个空格；回车也是分隔符，打多少个都只显示一个空格。 html编码：“&amp;” 开头 “；”结尾 空格： 小于：&lt; 大于：&gt; ** 回车标签： 水平线标签： 有序列表： **type属性：代表按哪种类型排序 1 a A i I** **reversed属性：倒序排序** **start属性：从第几个开始排序 只能写数字** 无序列表： type属性：disc（实心圆）---默认值 square（方块） circle（圈） ** 图片标签： src属性：1、网上的url 2、本地的绝对路径（图片与网页不在同一文件夹下） 记忆：绝对不行 3、本地的相对路径（图片与网页在同一文件夹下） alt属性：当图片无法加载时，显示文字。图片占位符 title属性：当鼠标移到照片上时，显示文字。图片提示符 ** 超链接标签： href属性：hyperText reference 超文本引用 所指向的超文本地址 https://www.baidu.com/ target属性：target=&quot;_blank&quot; 在新标签页打开链接 a标签可以包裹任何东西，但不能包裹自己 ** a标签也可用作锚点，记录位置 ** a标签还可以打电话，发邮件 a标签也可以用作协议限定符 表单标签： Username Password 你们最喜欢的明星 1、贝克汉姆 2、莱昂纳多 3、范勤阳 单选框需保持name一致 beijing shanghai tianjing **method属性：发送数据的方式 get/post** action属性：发送数据的地址 checked属性：默认选中 发送数据必须具备数据名（name）和数据值（value） # CSS部分 主流浏览器 及 其内核 IE trident Firefox Gecko Google Chrome Webkit/blink Safari Webkit Opera presto css：cascading style sheet 层叠样式表 一、引入css 1、行间样式 2、页面级css div{ width:100px; height:100px; } 3、外部css文件 二、css选择器 id选择器 **一个元素只能有一个id值 ** #名字 类选择器 多对多 .名字 标签选择器 直接写元素名称 如 div{color:#f40;} 通配符选择器 *{color:#f40;} 属性选择器 [id]：选中有id属性的元素 [id=\"only\"]：选中属性id=only的元素 父子选择器（后代选择器，所有后代，包括儿子和孙子） 直接子元素选择器（儿子选择器，不包括孙子） 并列选择器（div.demo 中间不需要加空格） 分组选择器 em,div,span{} 中间用逗号隔开 伪类选择器 :hover 伪元素：::before / ::after 选择器优先级：！important &gt; 行间样式 &gt; id &gt; class/属性选择器/伪类选择器 &gt; 标签/伪元素 &gt; * css权重 ！important infinity 行间样式 1000 id选择器 100 类选择器 属性选择器 标签选择器 伪元素 通配符选择器 0 三、css属性 font-size：字体大小，设置的是字体的高 font-weight：字体粗细 lighter normal bold bolder | 100 200 300 ———900 font-style：字体斜体 font-family：字体样式 color：字体颜色 transparent（透明色） 1、土鳖式（纯英文单词） 2、颜色代码 3、颜色函数 border：边框 text-align：规定元素中的文本的水平对齐方式 lien-height：一行文本的所占高度 text-indent：缩进 1em：1 * 该标签的font-size text-decoration：文本装饰 underline（下划线） cursor：当鼠标移到元素时，鼠标显示的样式 pointer（小手标）派 opacity：透明度 0-1 行级、块级、行级块 元素比较 行级元素 display：inline 块级元素 display：block 行级块元素 display：inline-block 不独占一行 不可以通过css改变宽高 独占一行 可以通过css改变宽高 不独占一行 可以通过css改变宽高 span、strong、em、a、del div、p、ul、ol、li、form、address img 凡是带有inline属性的元素，都有文字特性 编程手段：反向编程，先定义功能，后添加html .red{background-color:red;} .green{background-color:green;} .gray{background-color:gray;} .size1{width:100px;height:100px;} .size2{width:200px;height:200px;} .size3{width:300px;height:300px;} &lt;div class=&quot;red size1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;green size2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gray size3&quot;&gt;&lt;/div&gt; 标签选择器更多是用于自定义标签 通配符选择器更多是用于 设置padding和margin为0 四、盒子模型 margin：外边距 border：边框 padding：内边距 content：内容区 width和height 五、定位（层模型） position：relative（相对定位） | absolute（绝对定位）| fixed（固定定位） z-index：默认0 值越大，离你越近 定位属性需与left、right、top、bottom配合使用 当一个元素绝对定位（absolute）时，会脱离原来的层面跳到上一层进行定位 相对于最近的有定位的父级进行定位，如果没有，相对于文档（html）进行定位 当一个元素相对定位（relative）时，会保留原来的层面进行定位（灵魂出窍，但身体还在） 相对于自己原来的位置进行定位 企业开发当中，一般是用absolute定位，把relative当做标杆，即要定位的父级元素设置成relative 元素居中的标准方法 div{ position:absolute | fixed; left:50%; top:50; transform:translate(-50%,-50%); } 六、两栏布局 &lt;div calss=&quot;right&quot;&gt;&lt;/div&gt; &lt;div calss=&quot;left&quot;&gt;&lt;/div&gt; .right{ position:absolute; right0; width:100px; height:100px; background-color:#fcc; opacity:0.5; } .left{ margin-left:100px; height:100px; background-color:#123; } 七、margin塌陷与margin合并 margin塌陷中，触发BFC需要在父元素中添加 八、浮动模型 float：left/right float可以使元素排队，可以同时添加margin和padding 浮动元素会产生浮动流，所有产生浮动流的元素，块级元素看不到他们，产生了BFC的元素和文本类属性的元素（带有inline属性的元素）以及文本都能看到浮动元素。但不包括BFC中的position属性。浮动元素不保留原来位置 父级里面有浮动的字级，需要展示边框把字级包住。（包裹浮动元素的方法---通过伪元素来实现） 伪元素：一个标签产生的时候，就会产生 ::before 和 ::after 两个伪元素 伪元素天生是行级元素，如果需要设置宽和高，需要改成块级元素或行级块元素。 凡是设置了 position:absloute 和 float:left/right 系统会自动转换成 display:inline-block 九、清除浮动方法 &lt;style&gt; .wrapper{border:1px solid black;} .content{float:left; width:100px; height:100px; background-color:black; } .wrapper::after{ content:&quot;&quot;; clear:both;（清除浮动的元素必须是块元素） display:block; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 文字溢出处理（文字溢出容器，要打点展示） 处理单行文本： white-space：nowrap overflow：hidden text-overflow：ellipsis 处理多行文本： 企业级开发 图片用来替代文字，当css没有的时候，文字也要出现 text-indent：缩进文字的宽度 white-space：nowrap 强制不换行 overflow：hidden 行级元素只能嵌套行级元素 块级元素可以嵌套任何元素 特殊：p标签不能嵌套块级元素 a标签不能嵌套a标签 ** 十、两边留白（前提是父子级都是块级元素） &lt;style&gt; .wrapper{ background-color:#123; height:30px;} .content{ background-color:#0f0; width:1200px; height:30px; margin:0 auto; } &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 凡是带有inline的属性的标签都有文本的特点：写代码的时候，标签之间只要有文字分隔符，显示的时候就会有空隙 文本类元素是底对齐，如果一个文本类元素里面有文字，那外面的文字就会与里面的文字底对齐 ","link":"https://bonjouryy.github.io/post/HTML&CSS复习/"},{"title":"代码初始化","content":"一、引入初始化css样式表 https://cdn.bootcdn.net/ajax/libs/normalize/8.0.1/normalize.min.css 二、两边留白布局 .container{ max-width:&quot;1800px&quot;; 定义中间内容的宽度，这个一般是写死的。 margin:0 auto; display:&quot;block&quot;; } 三、左右浮动布局 .fl{ float:&quot;left&quot;; } .fr{ float:&quot;right&quot;; } 四、清除浮动 .clear-float::after{ content:&quot;&quot;; display:&quot;block&quot;; clear:&quot;both&quot;; } 五、分割系统 .colum-1{ float:&quot;left&quot;; width:&quot;10%&quot;; } .colum-2{ float:&quot;left&quot;; width:&quot;20%&quot;; } .colum-3{ float:&quot;left&quot;; width:&quot;30%&quot;; } .colum-4{ float:&quot;left&quot;; width:&quot;40%&quot;; } .colum-5{ float:&quot;left&quot;; width:&quot;50%&quot;; } .colum-6{ float:&quot;left&quot;; width:&quot;60%&quot;; } .colum-7{ float:&quot;left&quot;; width:&quot;70%&quot;; } .colum-8{ float:&quot;left&quot;; width:&quot;80%&quot;; } .colum-9{ float:&quot;left&quot;; width:&quot;90%&quot;; } ","link":"https://bonjouryy.github.io/post/代码初始化/"},{"title":"前端测试题","content":" ","link":"https://bonjouryy.github.io/post/前端测试题/"},{"title":"px、em、rem、vw、百分比的区别，你真的知道吗？","content":" px px是固定单位，其他几种都是相对单位。当我们把电脑屏幕的分辨率调为1440*900时，css里面设置的1px实际的物理尺寸就是屏幕宽度的1/1440。也就是说，px的实际大小由电脑的屏幕分辨率决定。 em 默认字体大小的倍数，这里的默认字体大小指的是继承自父元素的字体大小。比如给p元素设置font-size:2em，那么我们先去找p元素的父元素的字体是多少，如果是16px，那么p元素就是32px。如果是20px，那么p元素就是40px。一级一级向上找，浏览器默认的字体大小是16px。当给元素设置width: 2em，这里的默认字体大小是该元素自身的实际字体大小。就不是父元素的字体大小了。 rem 根元素(html 节点)字体大小的倍数。比如给p元素设置font-size:2rem，那么我们直接看html节点设置的font-size的大小，从而算出p元素的字体大小。 vw 1vw 代表浏览器视口宽度的1%。 1% font-size: 200% 和font-size: 2em 一样，表示字体大小是默认（继承自父亲）字体大小的2倍。 line-height: 200% 表示行高是自己字体大小的2倍。 width: 100%在标准盒模型下表示自己content的宽度等于父亲content的宽度，在IE盒模型下，表示自己content+padding+border的宽度等于父亲content的宽度。 题目: 下面代码中，body、article、p的实际字体大小分别是多少？ A、body是32px， article是16px，p是32px B、body是32px， article是32px，p是64px C、body是16px， article是16px，p是32px D、body是32px， article是32px，p是32px &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;em 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;article&gt; &lt;p&gt;hello 饥人谷&lt;/p&gt; &lt;/article&gt; &lt;style&gt; body{ font-size: 2em; } p { font-size: 2em; } &lt;/style&gt; &lt;/body&gt; &lt;/html&gt; // 答案：B。html默认是16px，body是2em，是默认的2倍32px， article是32px，p是article的2倍64px。 题目: 以下代码中，p的width的实际值是多少？(单选) A、32px B、64px C、128px D、256px &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;em 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;article&gt; &lt;p&gt;hello 饥人谷&lt;/p&gt; &lt;/article&gt; &lt;style&gt; body{ font-size: 2em; } p { font-size: 2em; width: 2em; } &lt;/style&gt; &lt;/body&gt; &lt;/html&gt; // 答案：C。p的宽度是默认字号的2倍， 字号是64px。 ","link":"https://bonjouryy.github.io/post/pxemremvwbai-fen-bi-de-qu-bie-ni-zhen-de-zhi-dao-ma/"},{"title":"CSS选择器优先级是怎样计算的？","content":"1、口诀记忆 选中且设置！important的 &gt; 权重高的 &gt; 权重相同位置靠后的 &gt; 来自继承的 行间样式 &gt; id选择器 &gt; 类选择器 = 伪类选择器 = 属性选择器 &gt; 标签选择器 = 伪元素选择器 1000 100 10 10 10 1 1 2、权重计算 千位：有行间属性该位得一分 百位：有ID选择器该位得一分 十位：有类选择器、属性选择器、伪类该位分别得一分 个位：有标签选择器、伪元素选择器该位分别得一分 3、举例 #header p.content.active 得分为 0121 .header p.active::before 得分为 0022 ","link":"https://bonjouryy.github.io/post/css-xuan-ze-qi-you-xian-ji-shi-zen-yang-ji-suan-de/"},{"title":"CSS3","content":"一、前缀 前缀 浏览器 -webkit chrome 和 safari -moz firefox -ms IE -o opera 兼容性查询网站：http://css.doyoe.com/ https://caniuse.com/ 预处理器(pre-processor)：sass / less cssNext 后处理器(post-processor)：autoprefixer 二、css 3 选择器 Relationship Selectors 关系系选择器 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; E + F 下一个满足条件的兄弟元素节点 div + p { background-color:red; } E ~ F 下面所有满足条件的兄弟元素节点 div + p { background-color:red; } Attribute Selectors 属性元素选择器 E[attr~='val'] 选中带有attr属性，并且属性值是以 val 独立存在的元素。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class='a'&gt;1&lt;/div&gt; &lt;div class='aa abc'&gt;2&lt;/div&gt; &lt;div class='a abc'&gt;3&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; div[class~='a']{ background-color:red; } E[attr | ='val'] 选中带有attr属性，并且属性值以 val 开头，或者 val- 开头的元素。 ","link":"https://bonjouryy.github.io/post/css3/"},{"title":"前端学习方法","content":"1. 三上之功 抓零碎时间学习，通行时可以看书：https://wangdoc.com/javascript/ 2. 费曼学习法 第一步：把它教给一个小孩子 第二步：回顾 第三步：将语言条理化，简化 第四步：传授 3. 互联网学习法 4. 类比法 用生活实践解释代码 函数节流与防抖 DDos 5. 推演法 用三段式逻辑推演 JS原型适合此法 6. 构建知识树 ","link":"https://bonjouryy.github.io/post/前端学习方法/"},{"title":"MDN笔记","content":"文件名和文件夹名字用小写，单词之间的分割使用中划线，而不是下划线。 ","link":"https://bonjouryy.github.io/post/mdn-bi-ji/"},{"title":"Git基本操作指令","content":" git init 首先，如果想要用git，需要先把项目变成git仓库。执行git init即可 git init test2 如果git init 后面加文件夹名，那么它会新建一个文件夹，并且把这个文件夹设置为git仓库。 ls -la 查看目录下的所有文件(包括隐藏文件) ctrl + l 清屏 git clone 地址 从网上克隆仓库 git status 查看仓库状态 git add . 将所有修改添加至暂存区 git commit -m &quot;描述&quot; 提交版本 git log 查看所有版本记录(查看总共记录了几次快照) git log -p 查看的详细的版本记录 git log --oneline 以一行展示的形式查看版本记录 git log --all 查看所有版本记录 git log --oneline --all --graph 以图形化的形式一行展示所有的log记录 git checkout xxx 回退到指定的历史节点（回退到指定的快照，吃后悔药，xxx代表节点的身份证） git tag -a 标签名 -m '描述' 附注标签（tag一般发布版本的时候使用） git tag 查看标签 git show 标签名 查看某个标签的详细信息 git checkout 标签名 回溯至标签所在的提交 git branch 分支名 创建分支 git checkout 分支名 切换分支 git checkout -b 分支名 创建并切换至分支 git merge 要合并的分支名 合并分支 git remote add 远程仓库 远程地址 添加远程仓库 git remote -v 列出所有远程仓库的详细信息 git push -u 远程名 分支名 上传代码 git clone 仓库地址 克隆(拷贝)仓库 ","link":"https://bonjouryy.github.io/post/git/"}]}